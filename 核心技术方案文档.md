# AQ-ç”¨æˆ·æ ‡ç­¾ç³»ç»Ÿ - æ ¸å¿ƒæŠ€æœ¯æ–¹æ¡ˆæ–‡æ¡£

## 1. ç³»ç»Ÿæ¦‚è¿°

### 1.1 é¡¹ç›®ç›®æ ‡

æœ¬é¡¹ç›®æ—¨åœ¨æ„å»ºä¸€ä¸ªæ™ºèƒ½ç”¨æˆ·åŒ»ç–—æ–¹å‘ç”»åƒç³»ç»Ÿã€‚ç³»ç»Ÿé€šè¿‡åˆ†æç”¨æˆ·ä¸åŒ»ç–—AIåŠ©æ‰‹çš„å¯¹è¯å†…å®¹ï¼Œåˆ©ç”¨å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰è‡ªåŠ¨æå–å¹¶ç®¡ç†ä¸€å¥—åŠ¨æ€æ›´æ–°çš„ç”¨æˆ·æ ‡ç­¾ï¼Œä»è€Œå½¢æˆå¤šç»´åº¦çš„ç”¨æˆ·ç”»åƒã€‚æœ€ç»ˆåˆ†æäººå‘˜å¯ä»¥æ ¹æ®æ­¤ç”»åƒæ¥åšå‡ºæ›´å¤šæœ‰æ•ˆçš„åˆ†æã€‚

### 1.2 æ ¸å¿ƒåŠŸèƒ½

*   **å®æ—¶å¯¹è¯åˆ†æ**: å®æ—¶å¤„ç†ç”¨æˆ·è¾“å…¥ï¼Œè¿›è¡Œè¯­ä¹‰ç†è§£ã€‚
*   **åŠ¨æ€æ ‡ç­¾æå–**: åŸºäºLLMä»å¯¹è¯ä¸­æå–å¤šä¸ªç»´åº¦çš„æ ‡ç­¾ã€‚
*   **åŠ¨æ€ç”¨æˆ·ç”»åƒ**: æ ‡ç­¾å…·æœ‰æƒé‡å’Œæ—¶æ•ˆæ€§ï¼Œä¼šéšç€æ—¶é—´æ¨ç§»å’Œæ–°çš„å¯¹è¯è¾“å…¥è€ŒåŠ¨æ€æ¼”è¿›ã€‚
*   **æ ‡ç­¾æº¯æº**: æä¾›æ ‡ç­¾æ¥æºçš„è¿½æº¯åŠŸèƒ½ï¼Œæ¸…æ™°å±•ç¤ºæ¯ä¸ªæ ‡ç­¾æ˜¯ç”±å“ªæ®µå¯¹è¯è§¦å‘çš„ã€‚

### 1.3 æŠ€æœ¯æ ˆ

*   **åç«¯**: Python + Flask
*   **æ ¸å¿ƒå¼•æ“**: åŸºäºLLMï¼ˆDeepSeekï¼‰çš„è‡ªå®šä¹‰RAGæµç¨‹
*   **æ•°æ®å­˜å‚¨**: æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿ (JSON)ï¼Œå¯æ‰©å±•è‡³SQLiteç­‰æ•°æ®åº“
*   **å‰ç«¯**: HTML, CSS, JavaScript (ç”¨äºDemoæ¼”ç¤º)

## 2. ç³»ç»Ÿæ¶æ„

ç³»ç»Ÿé‡‡ç”¨æ¨¡å—åŒ–çš„åˆ†å±‚æ¶æ„ï¼Œä¸»è¦åŒ…æ‹¬å‰ç«¯ã€åç«¯åº”ç”¨å±‚ã€æ ¸å¿ƒé€»è¾‘å±‚å’Œæ•°æ®å­˜å‚¨å±‚ã€‚

```mermaid
graph TD
    subgraph Browser["ç”¨æˆ·ç«¯"]
        A[å‰ç«¯ç•Œé¢]
    end

    subgraph Server["åç«¯æœåŠ¡å™¨ (Flask App)"]
        B[APIæ¥å£å±‚]
        subgraph CoreLogic["æ ¸å¿ƒé€»è¾‘å±‚"]
            C[æ ‡ç­¾æå–å™¨ TagExtractor]
            D[æ ‡ç­¾ç®¡ç†å™¨ TagManager]
            E[RAGå¼•æ“ LightRAGEngine]
            G[æ ‡ç­¾æº¯æºæ¨¡å— TagTracer]
        end
        H[LLM API]
    end

    subgraph Storage["æ•°æ®å­˜å‚¨å±‚ (æœ¬åœ°æ–‡ä»¶)"]
        I[ç”¨æˆ·ç”»åƒæ•°æ® user_tags.json]
        J[çŸ¥è¯†åº“ documents/]
        K[å¯¹è¯ä¸æ ‡ç­¾å†å² tag_timeline.json]
    end

    A -- HTTP Request --> B
    B -- è°ƒç”¨ --> C
    B -- è°ƒç”¨ --> D
    B -- è°ƒç”¨ --> F
    C -- "æå–æ–°æ ‡ç­¾" --> D
    F -- "è·å–ç”¨æˆ·ç”»åƒ" --> D
    F -- "æ£€ç´¢çŸ¥è¯†" --> E
    F -- "ç”Ÿæˆä¸ªæ€§åŒ–Prompt" --> H
    D -- "æ›´æ–°/æŸ¥è¯¢" --> I
    E -- "è¯»å–" --> J
    D -- "è®°å½•å†å²" --> K
    C -- "è°ƒç”¨LLM" --> H
```

*   **å‰ç«¯ç•Œé¢ (`index.html`)**: ç”¨æˆ·äº¤äº’çš„å…¥å£ï¼Œè´Ÿè´£å±•ç¤ºå¯¹è¯å’ŒåŠ¨æ€æ›´æ–°çš„ç”¨æˆ·ç”»åƒã€‚
*   **APIæ¥å£å±‚ (`web/app.py`)**: åŸºäºFlaskï¼Œæä¾›å¦‚`/api/chat`ç­‰æ ¸å¿ƒæ¥å£ï¼Œå¤„ç†å‰ç«¯è¯·æ±‚ï¼Œå¹¶è°ƒåº¦æ ¸å¿ƒé€»è¾‘å±‚å®Œæˆä»»åŠ¡ã€‚
*   **æ ¸å¿ƒé€»è¾‘å±‚ (`app/core/`)**:
    *   `TagExtractor`: è´Ÿè´£è°ƒç”¨LLMï¼Œä»ç”¨æˆ·è¾“å…¥ä¸­æå–ç»“æ„åŒ–çš„æ ‡ç­¾ä¿¡æ¯ã€‚
    *   `TagManager`: ç³»ç»Ÿçš„æ ¸å¿ƒï¼Œè´Ÿè´£ç®¡ç†ç”¨æˆ·æ‰€æœ‰æ ‡ç­¾çš„ç”Ÿå‘½å‘¨æœŸï¼ŒåŒ…æ‹¬æ–°å¢ã€å¼ºåŒ–ã€è¡°å‡ã€å†²çªè§£å†³å’Œç›¸ä¼¼æ€§åˆå¹¶ã€‚
    *   `LightRAGEngine`: å®ç°ç®€åŒ–çš„RAGæµç¨‹ï¼Œç®¡ç†ä¸ç”¨æˆ·ç›¸å…³çš„çŸ¥è¯†åº“ï¼Œå¹¶æä¾›æ£€ç´¢èƒ½åŠ›ã€‚
    *   `TagTracer`: è®°å½•æ ‡ç­¾çš„æ¯æ¬¡å˜åŒ–ï¼Œä¸ºæ ‡ç­¾æº¯æºåŠŸèƒ½æä¾›æ•°æ®æ”¯æŒã€‚
*   **æ•°æ®å­˜å‚¨å±‚ (`user_data/`)**: ä»¥ç”¨æˆ·IDè¿›è¡Œç‰©ç†éš”ç¦»ï¼Œæ¯ä¸ªç”¨æˆ·æ‹¥æœ‰ç‹¬ç«‹çš„ç”»åƒå’ŒçŸ¥è¯†åº“æ–‡ä»¶ã€‚
*   **LLM API**: å¤–éƒ¨å¤§æ¨¡å‹æœåŠ¡ï¼Œæ˜¯æ•´ä¸ªç³»ç»Ÿè¯­ä¹‰ç†è§£å’Œå†…å®¹ç”Ÿæˆèƒ½åŠ›çš„åŸºç¡€ã€‚

## 3. æ ¸å¿ƒæ¨¡å—è¯¦è§£

### 3.1 æ ‡ç­¾æå– (`TagExtractor`)

æ ‡ç­¾æå–æ˜¯æ„å»ºç”¨æˆ·ç”»åƒçš„ç¬¬ä¸€æ­¥ã€‚

*   **å·¥ä½œæµç¨‹**:
    1.  æ¥æ”¶åˆ°ç”¨æˆ·æ–‡æœ¬åï¼Œæ„å»ºä¸€ä¸ªç²¾å¿ƒè®¾è®¡çš„Promptã€‚
    2.  è¯¥PromptæŒ‡ç¤ºLLMæ‰®æ¼”ä¸€ä¸ªâ€œç”¨æˆ·ç”»åƒæ„å»ºå¸ˆâ€çš„è§’è‰²ï¼Œä»å¤šä¸ªé¢„è®¾ç»´åº¦ï¼ˆå¦‚â€œå¹´é¾„æ®µâ€ã€â€œæ€§åˆ«â€ï¼Œâ€œå…·ä½“æ„å›¾åˆ†ç±»â€ï¼‰åˆ†ææ–‡æœ¬ã€‚å¦‚æœæ–‡æœ¬æœ‰å¯¹åº”çš„æ¯”å¦‚ç”¨æˆ·çš„æ–‡æœ¬è•´å«ç€ç”¨æˆ·æ„å›¾æ˜¯å¯»æ±‚å°±åŒ»æŒ‡å¯¼ï¼Œå°±åœ¨ä¸€çº§æ ‡ç­¾ç”¨æˆ·æ„å›¾ä¸è½¬åŒ–é˜¶æ®µçš„äºŒçº§æ ‡ç­¾å…·ä½“æ„å›¾åˆ†ç±»åŒ¹é…ä¸Šå¯»æ±‚å°±åŒ»æŒ‡å¯¼ï¼Œä¹Ÿå°±æ˜¯æ‰“ä¸Šâ€å¯»æ±‚å°±åŒ»æŒ‡å¯¼â€œè¿™ä¸ªæ ‡ç­¾ã€‚
    3.  LLMè¢«è¦æ±‚ä»¥å›ºå®šçš„JSONæ ¼å¼è¿”å›ç»“æœï¼Œæ¯ä¸ªæ ‡ç­¾éƒ½åŒ…å«`tag`ï¼ˆæ ‡ç­¾åï¼‰ã€`confidence`ï¼ˆç½®ä¿¡åº¦ï¼‰å’Œ`evidence`ï¼ˆè¯æ®åŸæ–‡ï¼‰ã€‚
*   **å…³é”®è®¾è®¡**:
    *   **ç»“æ„åŒ–è¾“å‡º**: å¼ºåˆ¶LLMè¾“å‡ºJSONï¼Œä¾¿äºåç«¯ç›´æ¥è§£æï¼Œé¿å…äº†å¤æ‚çš„æ–‡æœ¬å¤„ç†ã€‚
    *   **å¤šç»´åº¦æå–**: é€šè¿‡PromptæŒ‡ä»¤ï¼Œä¸€æ¬¡è°ƒç”¨å³å¯ä»å¤šä¸ªç»´åº¦æå–æ ‡ç­¾ï¼Œæ•ˆç‡é«˜ã€‚
    *   **é™„å¸¦è¯æ®**: è¦æ±‚LLMæä¾›`evidence`ï¼Œä¸ºåç»­çš„æ ‡ç­¾æº¯æºæä¾›äº†ç›´æ¥ä¾æ®ã€‚

### 3.2 æ ‡ç­¾ç®¡ç† (`TagManager`)

`TagManager`æ˜¯æ•´ä¸ªç”¨æˆ·ç”»åƒç³»ç»Ÿçš„â€œå¤§è„‘â€ï¼Œå®ƒç»´æŠ¤ç€ä¸€ä¸ªå¤æ‚ä½†æœ‰åºçš„æ ‡ç­¾ä½“ç³»ã€‚

*   **æ ‡ç­¾æ•°æ®ç»“æ„**:
    é‡‡ç”¨å±‚çº§ç»“æ„ï¼š**ä¸€çº§æ ‡ç­¾(level_1_tag) -> äºŒçº§æ ‡ç­¾(level_2_tag) -> æ ‡ç­¾ (Tag)**ã€‚
    ```json
{
  "user_tags_system": [
    {
      "level_1_tag": "ç”¨æˆ·æ ¸å¿ƒç”»åƒ",
      "description": "æ­¤æ ‡ç­¾ä¸»è¦ç”¨äºè¯†åˆ«ç”¨æˆ·çš„åŸºæœ¬å±æ€§å’Œå…¶åœ¨å¥åº·ç®¡ç†ä¸­æ‰€æ‰®æ¼”çš„è§’è‰²ã€‚",
      "level_2_tags": [
        {
          "level_2_tag": "å¹´é¾„æ®µ",
          "values": [
            {
              "name": "å©´å¹¼å„¿ (0-3å²)",
              "description": "æ ¸å¿ƒå…³æ³¨ç‚¹ä¸ºå–‚å…»ã€å‘è‚²ã€å¸¸è§ç—…ï¼ˆå‘çƒ§ã€è…¹æ³»ï¼‰ã€ç–«è‹—æ¥ç§ï¼Œç”¨æˆ·é€šå¸¸ä¸ºå…¶çˆ¶æ¯ã€‚"
            },
            {
              "name": "å„¿ç«¥ (4-11å²)",
              "description": "æ ¸å¿ƒå…³æ³¨ç‚¹ä¸ºç”Ÿé•¿å‘è‚²ã€æ„å¤–ä¼¤å®³ã€å¸¸è§ä¼ æŸ“ç—…ã€è§†åŠ›ã€ç‰™é½¿å¥åº·ï¼Œç”¨æˆ·å¤šä¸ºå…¶çˆ¶æ¯ã€‚"
            },
            {
              "name": "é’å°‘å¹´ (12-17å²)",
              "description": "æ ¸å¿ƒå…³æ³¨ç‚¹ä¸ºé’æ˜¥æœŸå‘è‚²ã€å¿ƒç†å¥åº·ã€å­¦ä¸šå‹åŠ›ã€è¿åŠ¨æŸä¼¤ã€çš®è‚¤é—®é¢˜ï¼ˆç—¤ç–®ï¼‰ï¼Œç”¨æˆ·å¯èƒ½ä¸ºæœ¬äººæˆ–çˆ¶æ¯ã€‚"
            },
            {
              "name": "é’å¹´ (18-40å²)",
              "description": "æ ¸å¿ƒå…³æ³¨ç‚¹ä¸ºå·¥ä½œå‹åŠ›ã€ç”Ÿæ´»ä½œæ¯ã€ç”Ÿæ®–å¥åº·ã€å¸¸è§ç—…ï¼ˆæ„Ÿå†’ã€è‚ èƒƒç‚ï¼‰ã€è¿åŠ¨å¥èº«ã€çš®è‚¤ç®¡ç†ï¼Œç”¨æˆ·ä¸»è¦ä¸ºæœ¬äººã€‚"
            },
            {
              "name": "ä¸­å¹´ (41-65å²)",
              "description": "æ ¸å¿ƒå…³æ³¨ç‚¹ä¸ºæ…¢æ€§ç—…é£é™©ï¼ˆé«˜è¡€å‹ã€ç³–å°¿ç—…ï¼‰ã€ä½“æ£€æŒ‡æ ‡è§£è¯»ã€ç™Œç—‡ç­›æŸ¥ã€æ›´å¹´æœŸä¿å¥ï¼Œç”¨æˆ·å¤šä¸ºæœ¬äººæˆ–å­å¥³ã€‚"
            },
            {
              "name": "è€å¹´ (65å²ä»¥ä¸Š)",
              "description": "æ ¸å¿ƒå…³æ³¨ç‚¹ä¸ºæ…¢æ€§ç—…ç®¡ç†ã€å¤šé‡ç”¨è¯ã€éª¨éª¼å¥åº·ï¼ˆéª¨è´¨ç–æ¾ï¼‰ã€è®¤çŸ¥åŠŸèƒ½ï¼ˆé˜¿å°”èŒ¨æµ·é»˜ç—…ï¼‰ï¼Œç”¨æˆ·å¯èƒ½ä¸ºæœ¬äººæˆ–å­å¥³ã€‚"
            }
          ]
        },
        {
          "level_2_tag": "æ€§åˆ«",
          "values": [
            {
              "name": "ç”·",
              "description": "å…³æ³¨ç‚¹å¯èƒ½åå‘äºè¿åŠ¨æŸä¼¤ã€å¿ƒè¡€ç®¡å¥åº·ã€å‰åˆ—è…ºé—®é¢˜ã€è„±å‘ç­‰ã€‚"
            },
            {
              "name": "å¥³",
              "description": "å…³æ³¨ç‚¹å¯èƒ½åå‘äºå¦‡ç§‘å¥åº·ã€å­•äº§è‚²å„¿ã€çš®è‚¤ç®¡ç†ã€æ›´å¹´æœŸä¿å¥ç­‰ã€‚"
            }
          ]
        },
        {
          "level_2_tag": "æ‰€åœ¨åœ°åŒº",
          "values": [
            {
              "name": "ä¸€çº¿åŸå¸‚",
              "description": "åŒ»ç–—èµ„æºä¸°å¯Œï¼Œç”¨æˆ·å¯èƒ½æ›´å…³æ³¨å‰æ²¿åŒ»ç–—ä¿¡æ¯ã€é«˜ç«¯ç§ç«‹åŒ»ç–—æœåŠ¡ï¼Œå¯¹æ–°æŠ€æœ¯æ¥å—åº¦é«˜ã€‚"
            },
            {
              "name": "äºŒçº¿åŸå¸‚",
              "description": "åŒ»ç–—èµ„æºè¾ƒå¥½ï¼Œç”¨æˆ·å…³æ³¨ç‚¹å‡è¡¡ï¼Œå…¼é¡¾å…¬ç«‹åŒ»é™¢ä¿¡æ¯å’Œçº¿ä¸Šä¾¿æ·åŒ»ç–—æœåŠ¡ã€‚"
            },
            {
              "name": "ä¸‰çº¿åŠä»¥ä¸‹åŸå¸‚",
              "description": "åŒ»ç–—èµ„æºç›¸å¯¹æœ‰é™ï¼Œæ›´ä¾èµ–çº¿ä¸Šé—®è¯Šè§£å†³å¸¸è§ç—…ï¼Œå¯¹è¯å“ä¿¡æ¯ã€å¼‚åœ°å°±åŒ»æŒ‡å—æœ‰æ›´é«˜éœ€æ±‚ã€‚"
            }
          ]
        },
        {
          "level_2_tag": "å¥åº·è§’è‰²",
          "values": [
            {
              "name": "ä¸ªäººå¥åº·ç®¡ç†è€…",
              "description": "ä¸»è¦ä¸ºè‡ªå·±å’¨è¯¢ï¼Œé¢‘ç¹ä½¿ç”¨AIè¯Šå®¤ã€å¥åº·æ¡£æ¡ˆã€å‡é‡ä¸“åŒºç­‰åŠŸèƒ½ã€‚"
            },
            {
              "name": "å®¶åº­å¥åº·å†³ç­–è€…",
              "description": "å’¨è¯¢å†…å®¹æ¶‰åŠå®¶äººï¼ˆå¦‚å„¿ç«¥ã€è€äººï¼‰ï¼Œå¯èƒ½ä¸ºçˆ¶æ¯ã€å­å¥³è¿›è¡Œé—®è¯Šæˆ–æŸ¥è¯¢è¯å“ä¿¡æ¯ã€‚"
            },
            {
              "name": "æ…¢æ€§ç—…æ‚£è€…",
              "description": "é•¿æœŸã€å‘¨æœŸæ€§åœ°æŸ¥è¯¢ç‰¹å®šç–¾ç—…ï¼ˆå¦‚ç³–å°¿ç—…ã€é«˜è¡€å‹ï¼‰ï¼Œå¹¶å¯èƒ½ä½¿ç”¨å¥åº·æ•°æ®è‡ªåŠ¨åŒæ­¥åŠŸèƒ½ï¼ˆå¦‚è¡€ç³–ä»ªã€è¡€å‹è®¡ï¼‰ã€‚"
            },
            {
              "name": "ä¸´æ—¶æ±‚åŠ©è€…",
              "description": "ä½¿ç”¨é¢‘ç‡ä½ï¼Œå¤šä¸ºç´§æ€¥çš„ã€ä¸€æ¬¡æ€§çš„ç—‡çŠ¶æˆ–è¯å“æŸ¥è¯¢ã€‚"
            },
            {
              "name": "å¥åº·ç”Ÿæ´»è¿½æ±‚è€…",
              "description": "åå¥½ä½¿ç”¨å¥åº·å…»ç”Ÿã€é¥®é£Ÿçƒ­é‡è¯†åˆ«ã€å‡é‡ä¸“åŒºç­‰åŠŸèƒ½ã€‚"
            }
          ]
        }
      ]
    },
    {
      "level_1_tag": "äº§å“ä½¿ç”¨è·¯å¾„ä¸åå¥½",
      "description": "æ­¤æ ‡ç­¾ç”¨äºåˆ†æç”¨æˆ·ä¸äº§å“åŠŸèƒ½çš„äº¤äº’ä¹ æƒ¯ï¼Œæ­ç¤ºå…¶åå¥½çš„åŠŸèƒ½å’Œäº¤äº’æ–¹å¼ã€‚",
      "level_2_tags": [
        {
          "level_2_tag": "æ ¸å¿ƒåŠŸèƒ½åå¥½",
          "values": [
            {
              "name": "AIè¯Šæ–­ä¾èµ–å‹",
              "description": "æ ¸å¿ƒè·¯å¾„ä¸º `AIè¯Šå®¤`ã€`æ‹æŠ¥å‘Š`ã€`æ‹çš®è‚¤`ï¼Œå¼ºä¾èµ–AIè¿›è¡Œåˆæ­¥è¯Šæ–­ã€‚"
            },
            {
              "name": "ä¿¡æ¯æŸ¥è¯¢å¯¼å‘å‹",
              "description": "æ ¸å¿ƒè·¯å¾„ä¸º `ç–¾ç—…çŸ¥è¯†æŸ¥è¯¢`ã€`ç”¨è¯æŒ‡å¯¼`ã€`ååŒ»AIåˆ†èº«`ï¼Œå°†äº§å“ä½œä¸ºå¥åº·ç™¾ç§‘ä½¿ç”¨ã€‚"
            },
            {
              "name": "æœåŠ¡é—­ç¯é©±åŠ¨å‹",
              "description": "æ ¸å¿ƒè·¯å¾„æ¶‰åŠ `åœ¨çº¿é—®è¯Š` -> `é¢„çº¦æŒ‚å·` -> `çº¿ä¸Šä¹°è¯`ï¼Œæœ‰æ˜ç¡®çš„çº¿ä¸‹/çº¿ä¸ŠåŒ»ç–—æœåŠ¡éœ€æ±‚ã€‚"
            },
            {
              "name": "å¥åº·ç®¡ç†è·µè¡Œå‹",
              "description": "æ ¸å¿ƒè·¯å¾„ä¸º `å¥åº·æ¡£æ¡ˆç®¡ç†`ã€`å¥åº·æ•°æ®è‡ªåŠ¨åŒæ­¥`ï¼ˆç©¿æˆ´è®¾å¤‡ï¼‰ã€`å‡é‡ä¸“åŒº`ã€‚"
            },
            {
              "name": "åŒ»ä¿æœåŠ¡åˆ©ç”¨å‹",
              "description": "æ ¸å¿ƒè·¯å¾„ä¸º `åŒ»ä¿é—®ç­”`ã€`åŒ»ä¿ç ` ç›¸å…³åŠŸèƒ½ã€‚"
            }
          ]
        },
        {
          "level_2_tag": "äº¤äº’æ–¹å¼åå¥½",
          "values": [
            {
              "name": "è¯­éŸ³äº¤äº’å‹",
              "description": "åå¥½é€šè¿‡è¯­éŸ³è¿›è¡Œå¤šè½®å¯¹è¯é—®è¯Šã€‚"
            },
            {
              "name": "æ–‡æœ¬äº¤äº’å‹",
              "description": "åå¥½ä½¿ç”¨æ‰‹åŠ¨è¾“å…¥æ–‡å­—è¿›è¡ŒæŸ¥è¯¢ã€‚"
            },
            {
              "name": "å›¾åƒè¯†åˆ«å‹",
              "description": "é¢‘ç¹ä½¿ç”¨ `æ‹æŠ¥å‘Š`ã€`æ‹è¯ç›’`ã€`æ‹çš®è‚¤`ã€`é¥®é£Ÿçƒ­é‡è¯†åˆ«` ç­‰åŠŸèƒ½ã€‚"
            },
            {
              "name": "å°ç¨‹åºæœåŠ¡å‹",
              "description": "ç»å¸¸é€šè¿‡ç‚¹å‡»æŒ‰é’®è·³è½¬è‡³å°ç¨‹åºå®ŒæˆæŒ‚å·ã€ä¹°è¯ã€é—®è¯Šç­‰æ“ä½œã€‚"
            },
            {
              "name": "æ™ºèƒ½è®¾å¤‡è”åŠ¨å‹",
              "description": "å·²ç»‘å®šå¹¶åŒæ­¥VIVOã€åä¸ºã€é±¼è·ƒç­‰æ™ºèƒ½ç©¿æˆ´æˆ–æ£€æµ‹è®¾å¤‡çš„æ•°æ®ã€‚"
            }
          ]
        }
      ]
    },
    {
      "level_1_tag": "ç”¨æˆ·æ„å›¾ä¸è½¬åŒ–é˜¶æ®µ",
      "description": "æ­¤æ ‡ç­¾æ—¨åœ¨æ´å¯Ÿç”¨æˆ·ä½¿ç”¨äº§å“èƒŒåçš„æ·±å±‚éœ€æ±‚ï¼Œå¹¶åˆ¤æ–­å…¶åœ¨åŒ»ç–—å¥åº·æœåŠ¡æ¶ˆè´¹é“¾è·¯ä¸­æ‰€å¤„çš„é˜¶æ®µã€‚",
      "level_2_tags": [
        {
          "level_2_tag": "å…·ä½“æ„å›¾åˆ†ç±»",
          "values": [
            {
              "name": "ç—‡çŠ¶è‡ªæˆ‘è¯„ä¼°",
              "description": "â€œæˆ‘[ç—‡çŠ¶]ï¼Œå¯èƒ½æ˜¯ä»€ä¹ˆç—…ï¼Ÿâ€"
            },
            {
              "name": "ä¸“ä¸šæŠ¥å‘Šè§£è¯»",
              "description": "â€œå¸®æˆ‘çœ‹çœ‹è¿™å¼ åŒ–éªŒå•ã€‚â€"
            },
            {
              "name": "è¯å“ä¿¡æ¯æ ¸å¯¹",
              "description": "â€œè¿™ä¸ªè¯æ€ä¹ˆåƒï¼Ÿæœ‰ä»€ä¹ˆå‰¯ä½œç”¨ï¼Ÿâ€"
            },
            {
              "name": "å¯»æ±‚å°±åŒ»æŒ‡å¯¼",
              "description": "â€œæˆ‘åº”è¯¥æŒ‚å“ªä¸ªç§‘ï¼Ÿå“ªä¸ªåŒ»ç”Ÿå¥½ï¼Ÿâ€"
            },
            {
              "name": "ç”Ÿæ´»æ–¹å¼æ”¹å–„",
              "description": "â€œæˆ‘ä½“è´¨è™šå¯’è¯¥æ€ä¹ˆæ³¨æ„é¥®é£Ÿï¼Ÿâ€"
            },
            {
              "name": "ä»˜è´¹æœåŠ¡å’¨è¯¢",
              "description": "æ­£åœ¨ä½¿ç”¨æˆ–å’¨è¯¢ `åœ¨çº¿é—®è¯Š` ç­‰ä»˜è´¹æœåŠ¡ã€‚"
            },
            {
              "name": "åŒ»ä¿æ”¿ç­–/æµç¨‹æŸ¥è¯¢",
              "description": "å…³å¿ƒåŒ»ä¿æŠ¥é”€ã€å¼‚åœ°å°±åŒ»ç­‰é—®é¢˜ã€‚"
            }
          ]
        },
        {
          "level_2_tag": "è½¬åŒ–é˜¶æ®µ",
          "values": [
            {
              "name": "ä¿¡æ¯è®¤çŸ¥é˜¶æ®µ",
              "description": "å¹¿æ³›æµè§ˆå¥åº·ç§‘æ™®ã€ç–¾ç—…çŸ¥è¯†ã€‚"
            },
            {
              "name": "é—®é¢˜åˆ†æé˜¶æ®µ",
              "description": "ä½¿ç”¨AIè¯Šå®¤ã€æ‹æŠ¥å‘Šç­‰åŠŸèƒ½åˆ†æå…·ä½“å¥åº·é—®é¢˜ã€‚"
            },
            {
              "name": "å†³ç­–è¡ŒåŠ¨é˜¶æ®µ",
              "description": "æŸ¥è¯¢åŒ»ç”Ÿ/åŒ»é™¢ä¿¡æ¯ã€ä½¿ç”¨é¢„çº¦æŒ‚å·åŠŸèƒ½ã€‚"
            },
            {
              "name": "æœåŠ¡æ¶ˆè´¹é˜¶æ®µ",
              "description": "ä½¿ç”¨åœ¨çº¿é—®è¯Šï¼ˆä»˜è´¹ï¼‰ã€çº¿ä¸Šä¹°è¯ã€åŒ»ä¿ç æ”¯ä»˜ç­‰åŠŸèƒ½ã€‚"
            }
          ]
        }
      ]
    },
    {
      "level_1_tag": "ç”¨æˆ·å•†ä¸šä»·å€¼",
      "description": "æ­¤æ ‡ç­¾ä»è¿è¥å’Œå•†ä¸šåŒ–è§’åº¦å‡ºå‘ï¼Œå¯¹ç”¨æˆ·çš„ä»·å€¼è¿›è¡Œåˆ†å±‚ï¼Œä»¥ä¾¿è¿›è¡Œç²¾ç»†åŒ–è¿è¥ã€‚",
      "level_2_tags": [
        {
          "level_2_tag": "ä»·å€¼ç­‰çº§",
          "values": [
            {
              "name": "é«˜ä»·å€¼ç”¨æˆ·",
              "description": "æœ‰è¿‡ `åœ¨çº¿é—®è¯Š`ã€`çº¿ä¸Šä¹°è¯` ç­‰ä»˜è´¹è¡Œä¸ºï¼Œæˆ–é¢‘ç¹ä½¿ç”¨æœåŠ¡é—­ç¯ç›¸å…³åŠŸèƒ½ã€‚"
            },
            {
              "name": "é«˜æ½œåŠ›ç”¨æˆ·",
              "description": "é¢‘ç¹ä½¿ç”¨AIè¯Šæ–­ç›¸å…³åŠŸèƒ½ï¼Œæœ‰è½¬åŒ–ä¸ºä»˜è´¹ç”¨æˆ·çš„å¯èƒ½ã€‚"
            },
            {
              "name": "é«˜æ´»è·ƒç”¨æˆ·",
              "description": "æ¯æ—¥/å‘¨ç™»å½•ï¼Œä½†ä¸»è¦ä½¿ç”¨ä¿¡æ¯æŸ¥è¯¢ã€å¥åº·ç®¡ç†ç­‰å…è´¹åŠŸèƒ½ã€‚"
            },
            {
              "name": "ä½é¢‘ç”¨æˆ·",
              "description": "ä»…åœ¨æœ‰æ˜ç¡®ã€ç´§æ€¥éœ€æ±‚æ—¶å¶å°”ä½¿ç”¨ã€‚"
            },
            {
              "name": "æµå¤±é£é™©ç”¨æˆ·",
              "description": "æ›¾ä¸ºæ´»è·ƒç”¨æˆ·ï¼Œä½†è¿‘æœŸæ´»è·ƒåº¦æ˜¾è‘—ä¸‹é™ã€‚"
            }
          ]
        },
        {
          "level_2_tag": "ä»˜è´¹æ•æ„Ÿåº¦",
          "values": [
            {
              "name": "ä»·æ ¼ä¸æ•æ„Ÿ",
              "description": "ç›´æ¥ä½¿ç”¨ä»˜è´¹æœåŠ¡ã€‚"
            },
            {
              "name": "ä»·æ ¼æ•æ„Ÿ",
              "description": "å¤šæ¬¡è¿›å…¥ä»˜è´¹é¡µé¢ä½†æœªå®Œæˆæ”¯ä»˜ã€‚"
            },
            {
              "name": "çº¯å…è´¹ç”¨æˆ·",
              "description": "ä»æœªä½¿ç”¨è¿‡ä»»ä½•ä»˜è´¹ç›¸å…³åŠŸèƒ½ã€‚"
            }
          ]
        }
      ]
    }
  ]
}
    ```


## 4. æ•°æ®æµ

ä¸€æ¬¡å®Œæ•´çš„ç”¨æˆ·äº¤äº’æ•°æ®æµå¦‚ä¸‹ï¼š

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant FE as å‰ç«¯
    participant API as åç«¯API
    participant Extractor as æ ‡ç­¾æå–å™¨
    participant Manager as æ ‡ç­¾ç®¡ç†å™¨
    participant Generator as å›åº”ç”Ÿæˆå™¨
    participant LLM as å¤§è¯­è¨€æ¨¡å‹

    User->>FE: è¾“å…¥æ¶ˆæ¯å¹¶å‘é€
    FE->>API: è°ƒç”¨ /api/chat
    API->>Extractor: æå–æ ‡ç­¾(ç”¨æˆ·æ¶ˆæ¯)
    Extractor->>LLM: è¯·æ±‚æ ‡ç­¾æå–
    LLM-->>Extractor: è¿”å›JSONæ ¼å¼æ ‡ç­¾
    Extractor-->>API: è¿”å›æå–çš„æ ‡ç­¾
    API->>Manager: æ›´æ–°ç”¨æˆ·ç”»åƒ(æ–°æ ‡ç­¾)
    Manager->>Manager: æ‰§è¡Œå¼ºåŒ–ã€è¡°å‡ã€å†²çªè§£å†³ç­‰
    Generator->>Manager: è·å–æœ€æ–°ç”¨æˆ·ç”»åƒ
    Generator->>LLM: è¯·æ±‚ç”Ÿæˆå›åº”(å«ç”»åƒçš„Prompt)
    LLM-->>Generator: è¿”å›ä¸ªæ€§åŒ–å›åº”æ–‡æœ¬
    Generator-->>API: è¿”å›å›åº”æ–‡æœ¬
    API-->>FE: è¿”å›æœ€ç»ˆç»“æœ
    FE->>User: æ˜¾ç¤ºAIå›åº”å¹¶æ›´æ–°ç”»åƒ
```

## 5. å¦‚ä½•å¤ç°ç³»ç»Ÿ

### 5.1 ç¯å¢ƒå‡†å¤‡

1.  **å…‹éš†/ä¸‹è½½é¡¹ç›®**: è·å–æ‰€æœ‰æºä»£ç ã€‚
2.  **åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ**:
    ```bash
    python -m venv venv
    source venv/bin/activate  # on Linux/Mac
    ```
3.  **å®‰è£…ä¾èµ–**:
    ```bash
    pip install -r requirements.txt
    ```

### 5.2 é…ç½®

1.  æ‰¾åˆ°`config.yaml`æ–‡ä»¶ã€‚
2.  åœ¨`llm`éƒ¨åˆ†å¡«å…¥ä½ çš„LLM API Keyå’Œæ­£ç¡®çš„`base_url`ã€‚
    ```yaml
    llm:
      provider: "deepseek"
      model: "deepseek-chat"
      api_key: "sk-82ef8a72fca243c68624ed2c909ae906"
      base_url: "https://api.deepseek.com"
    ```

### 5.3 è¿è¡Œ

1.  ç¡®ä¿å¿…è¦çš„ç›®å½•å·²åˆ›å»ºï¼ˆ`run_demo.py`ä¼šè‡ªåŠ¨åˆ›å»ºï¼‰ã€‚
2.  åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹è¿è¡Œå¯åŠ¨è„šæœ¬ï¼š
    ```bash
    python run_demo.py
    ```
3.  ç³»ç»Ÿå¯åŠ¨åï¼Œåœ¨æµè§ˆå™¨ä¸­è®¿é—® `http://127.0.0.1:8080` å³å¯å¼€å§‹ä½“éªŒã€‚

## 6. æ ¸å¿ƒä»£ç å®ç°

### 6.1 ä¾èµ–é…ç½® (`requirements.txt`)
```txt
lightrag==0.1.0
openai==1.3.0
chromadb==0.4.15
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
python-multipart==0.0.6
jinja2==3.1.2
aiofiles==23.2.1
sqlite3
pandas==2.1.3
numpy==1.24.3
networkx==3.2
flask==3.0.0
PyYAML
```

### 6.2 é¡¹ç›®é…ç½® (`config.yaml`)
```yaml
# LightRAGæ ‡ç­¾ç³»ç»Ÿé…ç½®
app:
  name: "AQ-RAG-TagSystem"
  version: "1.0.0"
  debug: true

llm:
    provider: "deepseek"
    model: "deepseek-chat"
    api_key: "sk-82ef8a72fca243c68624ed2c909ae906"
    base_url: "https://api.deepseek.com" # é»˜è®¤ä¸ºOpenAI, å¯ä¿®æ”¹ä¸ºDeepSeekç­‰
  max_tokens: 500
  temperature: 0.7

embedding:
  provider: "openai"
  model: "text-embedding-ada-002"
  
storage:
  type: "local"
  base_path: "./user_data"
  backup_enabled: true
  cleanup_days: 90


```




    
  
### 6.4 åç«¯APIä¸è·¯ç”± (`web/app.py`)
```python
from flask import Flask, render_template, request, jsonify, session
import uuid
import json
from datetime import datetime
from app.core.lightrag_engine import LightRAGEngine
from app.core.tag_extractor import TagExtractor  
from app.core.tag_manager import TagManager

app = Flask(__name__)
app.secret_key = 'lightrag_demo_secret_key'

@app.route('/')
def index():
    """ä¸»é¡µ"""
    return render_template('index.html')

@app.route('/api/chat', methods=['POST'])
def chat():
    """èŠå¤©æ¥å£"""
    try:
        data = request.json
        user_message = data.get('message', '')
        
        # è·å–æˆ–åˆ›å»ºç”¨æˆ·ID
        if 'user_id' not in session:
            session['user_id'] = str(uuid.uuid4())
        
        user_id = session['user_id']
        
        # åˆå§‹åŒ–ç»„ä»¶
        tag_extractor = TagExtractor(user_id)
        tag_manager = TagManager(user_id)
        response_generator = ResponseGenerator(user_id)
        
        # æå–æ ‡ç­¾
        extracted_tags = tag_extractor.extract_tags_from_text(user_message)
        
        # æ›´æ–°æ ‡ç­¾
        updated_tags = tag_manager.update_tags(extracted_tags)
        
        
        # è®°å½•å¯¹è¯
        conversation_log = {
            "timestamp": datetime.now().isoformat(),
            "user_message": user_message,
            "assistant_response": response_data["response"],
            "extracted_tags": {k: [{"name": tag.name, "confidence": tag.confidence} for tag in v] for k, v in extracted_tags.items()},
            "search_strategy": response_data["search_strategy"]
        }
        
        return jsonify({
            "success": True,
            "response": response_data["response"],
            "user_profile": response_data["user_profile_snapshot"],
            "extracted_tags": {k: [{"name": tag.name, "confidence": tag.confidence} for tag in v] for k, v in extracted_tags.items()},
            "conversation_log": conversation_log
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/profile')
def get_profile():
    """è·å–ç”¨æˆ·ç”»åƒ"""
    try:
        if 'user_id' not in session:
            return jsonify({"success": False, "error": "ç”¨æˆ·æœªåˆå§‹åŒ–"})
        
        user_id = session['user_id']
        tag_manager = TagManager(user_id)
        user_tags = tag_manager.get_user_tags()
        
        return jsonify({
            "success": True,
            "user_tags": user_tags
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/add_knowledge', methods=['POST'])
def add_knowledge():
    """æ·»åŠ çŸ¥è¯†"""
    try:
        if 'user_id' not in session:
            return jsonify({"success": False, "error": "ç”¨æˆ·æœªåˆå§‹åŒ–"})
        
        data = request.json
        knowledge_text = data.get('text', '')
        metadata = data.get('metadata', {})
        
        user_id = session['user_id']
        lightrag = LightRAGEngine(user_id)
        
        result = lightrag.insert_knowledge(knowledge_text, metadata)
        
        return jsonify(result)
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/reset_user', methods=['POST'])
def reset_user():
    """é‡ç½®ç”¨æˆ·ï¼ˆæ–°å»ºç”¨æˆ·ä¼šè¯ï¼‰"""
    session.pop('user_id', None)
    return jsonify({"success": True, "message": "ç”¨æˆ·ä¼šè¯å·²é‡ç½®"})

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

### 6.5 RAGå¼•æ“ (`app/core/lightrag_engine.py`)
```python
import os
import json
import yaml
import openai
from typing import Dict, List, Optional

class LightRAGEngine:
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.user_data_path = f"user_data/{user_id}"
        self.ensure_user_directory()
        
        self.config = self._load_config()
        self.openai_client = self._create_openai_client()
        
    def _load_config(self):
        try:
            with open('config.yaml', 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except Exception as e:
            print(f"è­¦å‘Š: æ— æ³•åŠ è½½é…ç½®æ–‡ä»¶: {e}")
            return {}
    
    def _create_openai_client(self):
        api_key = self.config.get('llm', {}).get('api_key')
        base_url = self.config.get('llm', {}).get('base_url')
        
        if not api_key:
            raise ValueError("API key is required")
        
        return openai.OpenAI(api_key=api_key, base_url=base_url)
        
    def ensure_user_directory(self):
        os.makedirs(self.user_data_path, exist_ok=True)
        os.makedirs(f"{self.user_data_path}/documents", exist_ok=True)
        
    def insert_knowledge(self, text: str, metadata: Dict = None):
        try:
            doc_data = {
                "content": text,
                "metadata": metadata or {},
                "user_id": self.user_id,
                "timestamp": json.dumps({"created": "now"}, default=str)
            }
            docs_dir = f"{self.user_data_path}/documents"
            os.makedirs(docs_dir, exist_ok=True)
            existing_files = [f for f in os.listdir(docs_dir) if f.endswith('.json')]
            doc_file = f"{docs_dir}/doc_{len(existing_files)}.json"
            
            with open(doc_file, 'w', encoding='utf-8') as f:
                json.dump(doc_data, f, ensure_ascii=False, indent=2)
                
            return {"status": "success", "message": "çŸ¥è¯†æ’å…¥æˆåŠŸ"}
        except Exception as e:
            return {"status": "error", "message": f"æ’å…¥å¤±è´¥: {str(e)}"}
    
    def query_knowledge(self, query: str, mode: str = "hybrid") -> str:
        try:
            documents_dir = f"{self.user_data_path}/documents"
            if not os.path.exists(documents_dir):
                return "çŸ¥è¯†åº“ä¸ºç©ºï¼Œè¯·å…ˆæ·»åŠ ä¸€äº›çŸ¥è¯†ã€‚"
            
            relevant_docs = []
            doc_files = [f for f in os.listdir(documents_dir) if f.endswith('.json')]
            
            for doc_file in doc_files[:5]:
                doc_path = os.path.join(documents_dir, doc_file)
                try:
                    with open(doc_path, 'r', encoding='utf-8') as f:
                        doc_data = json.load(f)
                        content = doc_data.get('content', '')
                        
                        query_words = query.lower().split()
                        content_lower = content.lower()
                        
                        if any(word in content_lower for word in query_words):
                            relevant_docs.append(content[:200] + "..." if len(content) > 200 else content)
                except Exception as e:
                    continue
            
            if relevant_docs:
                return f"æ‰¾åˆ°ç›¸å…³çŸ¥è¯†:\n" + "\n\n".join(relevant_docs)
            else:
                return "æœªæ‰¾åˆ°ç›¸å…³çŸ¥è¯†ï¼Œä½†æˆ‘ä¼šåŸºäºä¸€èˆ¬çŸ¥è¯†æ¥å›ç­”æ‚¨çš„é—®é¢˜ã€‚"
                
        except Exception as e:
            return f"æŸ¥è¯¢é”™è¯¯: {str(e)}"
```

### 6.6 æ ‡ç­¾æå–å™¨ (`app/core/tag_extractor.py`)
```python
import json
import re
import yaml
import openai
from datetime import datetime
from typing import Dict, List
from dataclasses import dataclass

@dataclass
class TagInfo:
    name: str
    confidence: float
    evidence: str
    category: str
    subcategory: str

class TagExtractor:
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.config = self._load_config()
        self.llm_client = self._create_llm_client()
        self.tag_categories = self.config.get('tag_system', {}).get('categories', {})
        
    def _load_config(self):
        with open("config.yaml", 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
            
    def _create_llm_client(self):
        return openai.OpenAI(
            api_key=self.config.get('llm', {}).get('api_key'),
            base_url=self.config.get('llm', {}).get('base_url')
        )
        
    def extract_tags_from_text(self, text: str, context: Dict = None) -> Dict[str, List[TagInfo]]:
        extraction_prompt = self._build_extraction_prompt(text, context)
        
        try:
            llm_response = self.llm_client.chat.completions.create(
                model=self.config.get('llm',{}).get('model'),
                messages=[{"role": "user", "content": extraction_prompt}],
                max_tokens=self.config.get('llm',{}).get('max_tokens', 1000),
                temperature=self.config.get('llm',{}).get('temperature', 0.3),
                response_format={"type": "json_object"}
            ).choices[0].message.content
            
            extracted_tags = self._parse_llm_response(llm_response, text)
            return extracted_tags
            
        except Exception as e:
            print(f"æ ‡ç­¾æå–é”™è¯¯: {e}")
            return {}
    
    def _build_extraction_prompt(self, text: str, context: Dict = None) -> str:
        # This prompt needs to be carefully designed based on the tag structure in config.yaml
        # Here is a generic example
        prompt = f"""
        Analyze the user text and extract tags based on the provided categories.
        User text: "{text}"
        
        Categories and subcategories:
        {json.dumps(self.tag_categories, indent=2, ensure_ascii=False)}
        
        Output in JSON format with keys for each main category. For each tag, provide name, confidence (0.1-1.0), evidence from the text, and the subcategory key.
        Example format:
        {{
          "demographic_info": [
            {{
              "tag_name": "20-30å²",
              "confidence": 0.8,
              "evidence": "æˆ‘ä»Šå¹´25å²",
              "subcategory": "age"
            }}
          ],
          "interests_hobbies": []
        }}
        """
        return prompt
    
    def _parse_llm_response(self, response: str, original_text: str) -> Dict[str, List[TagInfo]]:
        try:
            tag_data = json.loads(response)
            parsed_tags = {}
            for category_key, tags in tag_data.items():
                if category_key not in parsed_tags:
                    parsed_tags[category_key] = []
                for tag_info in tags:
                    tag = TagInfo(
                        name=tag_info.get("tag_name", ""),
                        confidence=tag_info.get("confidence", 0.5),
                        evidence=tag_info.get("evidence", ""),
                        category=category_key,
                        subcategory=tag_info.get("subcategory", "other")
                    )
                    parsed_tags[category_key].append(tag)
            return parsed_tags
        except Exception as e:
            print(f"è§£æLLMå“åº”é”™è¯¯: {e}")
            return {}
```

### 6.7 æ ‡ç­¾ç®¡ç†å™¨ (`app/core/tag_manager.py`)
```python
import json
import os
from datetime import datetime, timedelta
from typing import Dict, List
from app.core.tag_extractor import TagInfo

class TagManager:
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.user_data_path = f"user_data/{user_id}"
        self.tags_file = f"{self.user_data_path}/user_tags.json"
        self.timeline_file = f"{self.user_data_path}/tag_timeline.json"
        self._ensure_tag_files()
        
    def _ensure_tag_files(self):
        os.makedirs(self.user_data_path, exist_ok=True)
        if not os.path.exists(self.tags_file):
            self._create_empty_tags_file()
        if not os.path.exists(self.timeline_file):
            with open(self.timeline_file, 'w', encoding='utf-8') as f:
                json.dump({"user_id": self.user_id, "tag_events": []}, f)

    def _create_empty_tags_file(self):
        # This structure should match your desired user profile structure
        # A more complex example with subcategories is in the project files
        empty_tags = {
            "user_id": self.user_id,
            "created_at": datetime.now().isoformat(),
            "last_updated": datetime.now().isoformat(),
            "tag_dimensions": {
                # ... dimensions based on config ...
            },
            "computed_metrics": {}
        }
        with open(self.tags_file, 'w', encoding='utf-8') as f:
            json.dump(empty_tags, f, ensure_ascii=False, indent=2)

    def update_tags(self, extracted_tags: Dict[str, List[TagInfo]]) -> Dict:
        current_tags = self._load_current_tags()
        
        for dimension, new_tags in extracted_tags.items():
            if dimension in current_tags["tag_dimensions"]:
                # Logic to update tags, handle subcategories, etc.
                self._update_dimension_tags(
                    current_tags["tag_dimensions"][dimension], 
                    new_tags
                )
        
        self._recalculate_weights_and_metrics(current_tags)
        current_tags["last_updated"] = datetime.now().isoformat()
        self._save_tags(current_tags)
        self._record_tag_timeline(extracted_tags)
        return current_tags

    def _load_current_tags(self) -> Dict:
        with open(self.tags_file, 'r', encoding='utf-8') as f:
            return json.load(f)

    def _save_tags(self, tags_data: Dict):
        with open(self.tags_file, 'w', encoding='utf-8') as f:
            json.dump(tags_data, f, ensure_ascii=False, indent=2)

    def _update_dimension_tags(self, dimension_data: Dict, new_tags: List[TagInfo]):
        # This is a complex part of the logic.
        # It needs to handle subcategories, find existing tags,
        # reinforce them, or create new ones.
        # Also, conflict resolution and similarity detection would be called here.
        pass

    def _apply_time_decay(self, active_tags: List[Dict]):
        now = datetime.now()
        for tag in active_tags:
            last_reinforced = datetime.fromisoformat(tag["last_reinforced"])
            days_since = (now - last_reinforced).days
            decay_factor = max(0.1, 1.0 - (days_since * tag.get("decay_rate", 0.1) / 30))
            tag["current_weight"] = tag["avg_confidence"] * decay_factor

    def _recalculate_weights_and_metrics(self, tags_data: Dict):
        # Logic to calculate dominant tags, dimension weights, stability,
        # and overall metrics like emotional_health_index.
        pass

    def _record_tag_timeline(self, extracted_tags: Dict[str, List[TagInfo]]):
        # Appends the new extraction event to the timeline file.
        pass

    def get_user_tags(self) -> Dict:
        return self._load_current_tags()
```



### 6.9 å‰ç«¯ç•Œé¢ (`web/templates/index.html`)
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AQ-ç”¨æˆ·æ ‡ç­¾ç³»ç»Ÿ</title>
    <style>
        body { font-family: sans-serif; margin: 0; display: flex; height: 100vh; background-color: #f0f2f5; }
        .container { display: flex; width: 100%; height: 100%; }
        .chat-section { flex: 2; display: flex; flex-direction: column; margin: 10px; border-radius: 8px; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .profile-section { flex: 1; margin: 10px; padding: 20px; border-radius: 8px; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow-y: auto; }
        .chat-header { padding: 20px; background: #4A90E2; color: white; border-radius: 8px 8px 0 0; }
        .chat-messages { flex: 1; padding: 20px; overflow-y: auto; }
        .message { margin-bottom: 15px; padding: 10px 15px; border-radius: 18px; max-width: 80%; word-wrap: break-word; }
        .user-message { background: #007bff; color: white; margin-left: auto; border-bottom-right-radius: 4px; }
        .assistant-message { background: #e9ecef; color: #333; border-bottom-left-radius: 4px; }
        .chat-input { display: flex; padding: 20px; border-top: 1px solid #ddd; }
        #messageInput { flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 20px; }
        .chat-input button { margin-left: 10px; padding: 10px 20px; border: none; border-radius: 20px; background-color: #007bff; color: white; cursor: pointer; }
    </style>
</head>
<body>
    <div class="container">
        <div class="chat-section">
            <div class="chat-header"><h2>ğŸ¤– AQ-æ™ºèƒ½åŒ»ç–—åŠ©æ‰‹</h2></div>
            <div class="chat-messages" id="chatMessages">
                <div class="message assistant-message">ä½ å¥½ï¼éšä¾¿èŠç‚¹ä»€ä¹ˆå§ï¼</div>
            </div>
            <div class="chat-input">
                <input type="text" id="messageInput" placeholder="è¾“å…¥ä½ æƒ³è¯´çš„è¯..." onkeypress="if(event.key==='Enter') sendMessage()">
                <button onclick="sendMessage()">å‘é€</button>
            </div>
        </div>
        <div class="profile-section">
            <h2 id="profile-title">ğŸ‘¤ ç”¨æˆ·ç”»åƒ</h2>
            <div id="profileContent"><p>å¼€å§‹å¯¹è¯åï¼Œè¿™é‡Œä¼šæ˜¾ç¤ºç”¨æˆ·ç”»åƒæ ‡ç­¾ã€‚</p></div>
        </div>
    </div>

    <script>
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            if (!message) return;

            addMessageToChat('user', message);
            input.value = '';

            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message })
                });
                const data = await response.json();

                if (data.success) {
                    addMessageToChat('assistant', data.response);
                    updateProfile(data.user_profile);
                } else {
                    addMessageToChat('assistant', 'é”™è¯¯: ' + data.error);
                }
            } catch (error) {
                addMessageToChat('assistant', 'ç½‘ç»œè¿æ¥é”™è¯¯ã€‚');
            }
        }

        function addMessageToChat(sender, text) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            messageDiv.textContent = text;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function updateProfile(profileData) {
            const profileContent = document.getElementById('profileContent');
            if (!profileData || !profileData.active_dimensions) {
                profileContent.innerHTML = '<p>æš‚æ— ç”»åƒæ•°æ®ã€‚</p>';
                return;
            }
            let html = `<h4>ç”»åƒæˆç†Ÿåº¦: ${(profileData.profile_maturity * 100).toFixed(1)}%</h4>`;
            profileData.active_dimensions.forEach(dim => {
                html += `
                    <div>
                        <strong>${dim.dimension}:</strong> 
                        <span>${dim.dominant_tag} (æƒé‡: ${dim.weight.toFixed(2)})</span>
                    </div>
                `;
            });
            profileContent.innerHTML = html;
        }
    </script>
</body>
</html>
```
